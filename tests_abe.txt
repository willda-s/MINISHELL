1 - tentative d'expand sans env => invlaid write


FIXED
------------------------------------------

2 - (unset doit prend N parametres)    need fixe UNSET LEAK

FIXED
------------------------------------------

3 -getpid() interdit

FIXED
------------------------------------------

4 - $ > out | cat | cat | ls

==> bloque dans cat

FIXED
------------------------------------------

5 -fork() pete => fd leaks
et aussi
6 - Nieme fork() qui pete => process zombie

FIXED
------------------------------------------

7 - pipe() qui pete => memory leaks 
et aussi
8 - Nieme pipe() qui pete => fd leaks

FIXED
------------------------------------------

dup_fd() dans ft_fd.c

9 - dup2 STDOUT qui pete => fd leak
10 - dup2 STDIN qui pete => bloque dans le cat + fd leaks

FIXED
------------------------------------------

11 - redir in (<) depuis file qui n'existe pas => invalid reads | memory leaks + segfault

FIXED
------------------------------------------

12 - si ft_strdup dans ft_expand_word() dans expandf.c pete ==> memory leaks

FIXED
------------------------------------------

13 - manque de coherence si ft_strdup pete dans check_redirout/redirin dans init_filename ==> quitte le programme alors que dans la plupart des autres cas pas de quittation


------------------------------------------

14 - HD => fichier supprime lorsque l'on est dedans -> blocke comme erreur 4


------------------------------------------

15 - file_create() - echec du strjoin ou du itoa, vous essayez d'open qd meme avant de quitter le programme completement

------------------------------------------

16 - HD => pour une protec maximale et eviter tout probleme, besoin d'open hd_in et hd_out au meme moment, puis directement unlink le fichier. Ainsi il ne sera ni corruptible ni supprimable (ce qui pourrait generer des erreurs voire des leaks/crash/invalid syscall open...)

------------------------------------------

17 - HD => heredoc_utils.c
	redir->filename = ft_strdup(file);
si strdup echoue, segfault + leak + invalid reada
